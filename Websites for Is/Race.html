<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Jumanji Jungle Rush</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a2e1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }

        .stat-box { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px; border: 2px solid #4caf50; }
        #boost-meter { color: #ffeb3b; }
        #lap-counter { color: #00e676; }

        #center-msg {
            position: absolute;
            top: 40%;
            width: 100%;
            text-align: center;
            font-size: 60px;
            font-weight: 900;
            color: #ff9800;
            text-shadow: 4px 4px 0 #3e2723;
            display: none;
            animation: popIn 0.5s ease-out;
        }

        @keyframes popIn {
            0% { transform: scale(0); }
            80% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="hud-top">
        <div class="stat-box" id="lap-counter">LAP: 1 / 5</div>
        <div class="stat-box" id="pos-counter">POS: 1/4</div>
        <div class="stat-box" id="boost-meter">SPEED: NORMAL</div>
    </div>
    <div id="center-msg">JUMANJI!</div>
    <div id="instructions">ARROWS to Drive | SPACE to Drift/Brake</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- CONFIG ---
    const TRACK_LENGTH = 4000;
    const LANE_WIDTH = 80;
    const TOTAL_LAPS = 5;
    
    // --- GLOBALS ---
    let scene, camera, renderer;
    let player, rivals = [];
    let obstacles = [], ramps = [], boosts = [], scenery = [];
    let currentLap = 1;
    let playerDist = 0;
    let gameActive = true;
    
    // Physics
    let velocity = { x: 0, y: 0, z: 0 };
    let speed = 0;
    const MAX_SPEED = 2.5;
    const BOOST_SPEED = 4.5;
    const ACCEL = 0.02;
    const GRAVITY = 0.03;
    const JUMP_FORCE = 1.2;
    let isAirborne = false;
    let isBoosting = false;
    let boostTimer = 0;

    // Input
    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

    function init() {
        // 1. Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 10, 150);

        // 2. Camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        // 3. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 4. Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 5. The World (Infinite Jungle Plane)
        createGround();
        
        // 6. The Player (Dr. Bravestone - Grey/Silver Muscle Car vibe)
        player = createRacer(0xaaaaaa, 0);
        
        // 7. The Rivals
        // Ruby (Red), Mouse (Green), Oberon (Blue)
        rivals.push({ mesh: createRacer(0xd32f2f, -10), speed: 2.0, name: "Ruby", dist: 0 });
        rivals.push({ mesh: createRacer(0x388e3c, 10), speed: 1.8, name: "Mouse", dist: 0 });
        rivals.push({ mesh: createRacer(0x1976d2, 5), speed: 1.6, name: "Oberon", dist: 0 });

        // 8. Level Generation
        generateTrackObjects();

        // Listeners
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);
        window.addEventListener('resize', onResize);

        animate();
    }

    function createRacer(color, xOffset) {
        const group = new THREE.Group();
        
        // Body
        const bodyGeo = new THREE.BoxGeometry(1.5, 0.8, 3);
        const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.castShadow = true;
        body.position.y = 0.5;
        group.add(body);

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const positions = [
            [-0.8, 0.4, 1], [0.8, 0.4, 1], [-0.8, 0.4, -1], [0.8, 0.4, -1]
        ];
        positions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(...pos);
            group.add(wheel);
        });

        group.position.set(xOffset, 0, 0);
        scene.add(group);
        return group;
    }

    function createGround() {
        // The Track
        const geo = new THREE.PlaneGeometry(LANE_WIDTH, 10000);
        const mat = new THREE.MeshStandardMaterial({ color: 0x5d4037 }); // Dirt road
        const road = new THREE.Mesh(geo, mat);
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);

        // The Grass
        const grassGeo = new THREE.PlaneGeometry(1000, 10000);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32 });
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.1;
        grass.receiveShadow = true;
        scene.add(grass);
    }

    function generateTrackObjects() {
        // Procedurally generate obstacles and decorations
        for(let i = 50; i < TRACK_LENGTH; i+=80) {
            // Random chance for objects
            const rand = Math.random();
            const xPos = (Math.random() - 0.5) * (LANE_WIDTH - 10);

            if (rand > 0.8) {
                // SCENERY (Trees)
                createTree(xPos * 2, -i); // Wide dispersion
            } 
            
            if (rand < 0.1) {
                // OBSTACLE (Rock)
                createRock(xPos, -i);
            } else if (rand > 0.1 && rand < 0.15) {
                // RAMP (Blue wedge)
                createRamp(xPos, -i);
            } else if (rand > 0.15 && rand < 0.2) {
                // BOOST (Yellow Pad)
                createBoost(xPos, -i);
            }
        }
    }

    function createTree(x, z) {
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.8, 4),
            new THREE.MeshStandardMaterial({ color: 0x4e342e })
        );
        trunk.position.set(x, 2, z);
        
        const leaves = new THREE.Mesh(
            new THREE.ConeGeometry(3, 6, 8),
            new THREE.MeshStandardMaterial({ color: 0x1b5e20 })
        );
        leaves.position.set(0, 3, 0);
        trunk.add(leaves);
        scene.add(trunk);
        scenery.push(trunk);
    }

    function createRock(x, z) {
        const geo = new THREE.DodecahedronGeometry(1.5);
        const mat = new THREE.MeshStandardMaterial({ color: 0x757575 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, 1, z);
        mesh.castShadow = true;
        scene.add(mesh);
        obstacles.push(mesh);
    }

    function createRamp(x, z) {
        const geo = new THREE.CylinderGeometry(0, 3, 8, 4);
        const mat = new THREE.MeshStandardMaterial({ color: 0x29b6f6, emissive: 0x0044aa });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.y = Math.PI / 4; // Angle edge
        mesh.rotation.x = Math.PI / 2; // Lay flat
        mesh.scale.z = 0.3; // Flatten
        mesh.position.set(x, 0.5, z);
        scene.add(mesh);
        ramps.push(mesh); // Store for collision
    }

    function createBoost(x, z) {
        const geo = new THREE.BoxGeometry(4, 0.2, 4);
        const mat = new THREE.MeshStandardMaterial({ color: 0xffea00, emissive: 0xffaa00 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, 0.1, z);
        scene.add(mesh);
        boosts.push(mesh);
    }

    // --- GAME LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        if(!gameActive) return;

        handleInput();
        updatePhysics();
        updateRivals();
        updateCamera();
        checkCollisions();
        updateWorldWrap(); // The "Infinite" Lap logic

        renderer.render(scene, camera);
    }

    function handleInput() {
        if (keys['ArrowUp']) speed += ACCEL;
        else speed -= ACCEL / 2;
        
        if (keys['ArrowDown']) speed -= ACCEL * 2;
        
        let turnSpeed = 0.8;
        if (keys['ArrowLeft']) player.position.x -= turnSpeed;
        if (keys['ArrowRight']) player.position.x += turnSpeed;

        // Constrain Speed
        let max = isBoosting ? BOOST_SPEED : MAX_SPEED;
        speed = Math.max(0, Math.min(speed, max));
        
        // Boost decay
        if (isBoosting) {
            boostTimer--;
            if (boostTimer <= 0) {
                isBoosting = false;
                document.getElementById('boost-meter').innerText = "SPEED: NORMAL";
                document.getElementById('boost-meter').style.color = "white";
            }
        }
    }

    function updatePhysics() {
        // Apply Velocity
        player.position.z -= speed;
        playerDist += speed;

        // Gravity / Jumps
        if (player.position.y > 0) {
            velocity.y -= GRAVITY;
            player.position.y += velocity.y;
            isAirborne = true;
        }
        
        // Floor collision
        if (player.position.y <= 0) {
            player.position.y = 0;
            velocity.y = 0;
            isAirborne = false;
            player.rotation.x = 0;
        } else {
            // Air rotation effect
            player.rotation.x = -0.2;
        }

        // Walls
        if(player.position.x > LANE_WIDTH/2) player.position.x = LANE_WIDTH/2;
        if(player.position.x < -LANE_WIDTH/2) player.position.x = -LANE_WIDTH/2;
    }

    function updateRivals() {
        rivals.forEach(rival => {
            rival.mesh.position.z -= rival.speed;
            rival.dist += rival.speed;
            
            // Simple AI to dodge randomly (wobble)
            rival.mesh.position.x += Math.sin(Date.now() * 0.001 + rival.speed) * 0.1;
        });
        
        // Calculate Rank
        let rank = 1;
        rivals.forEach(r => {
            if (r.dist > playerDist) rank++;
        });
        document.getElementById('pos-counter').innerText = "POS: " + rank + "/4";
    }

    function checkCollisions() {
        const pBox = new THREE.Box3().setFromObject(player);

        // Obstacles (Rocks)
        obstacles.forEach(obs => {
            const oBox = new THREE.Box3().setFromObject(obs);
            if (pBox.intersectsBox(oBox)) {
                speed = -0.5; // Crash bounce back
                player.position.z += 5;
            }
        });

        // Ramps
        ramps.forEach(ramp => {
            if (player.position.distanceTo(ramp.position) < 3 && !isAirborne) {
                velocity.y = JUMP_FORCE;
            }
        });

        // Boosts
        boosts.forEach(boost => {
            if (player.position.distanceTo(boost.position) < 3) {
                isBoosting = true;
                boostTimer = 120; // 2 seconds @ 60fps
                speed = BOOST_SPEED;
                document.getElementById('boost-meter').innerText = "SPEED: SMOLDER FLAME!";
                document.getElementById('boost-meter').style.color = "#ffeb3b";
            }
        });
    }

    function updateWorldWrap() {
        // The Magic Loop: If player goes past -1000, wrap world objects forward
        // Actually, simpler: Player keeps moving Z-. We check absolute distance for Lap.
        
        const LAP_DIST = 2000;
        const newLap = Math.floor(playerDist / LAP_DIST) + 1;
        
        if (newLap > currentLap) {
            currentLap = newLap;
            if (currentLap > TOTAL_LAPS) {
                endGame("YOU WIN!");
            } else {
                document.getElementById('lap-counter').innerText = "LAP: " + currentLap + " / " + TOTAL_LAPS;
                showMsg("LAP " + currentLap);
            }
            // Increase Rival Difficulty
            rivals.forEach(r => r.speed += 0.2);
        }
    }

    function updateCamera() {
        // Smooth follow
        camera.position.x = player.position.x * 0.3;
        camera.position.z = player.position.z + 10;
        camera.position.y = player.position.y + 5;
        camera.lookAt(player.position.x, player.position.y, player.position.z - 10);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function showMsg(text) {
        const el = document.getElementById('center-msg');
        el.innerText = text;
        el.style.display = 'block';
        setTimeout(() => el.style.display = 'none', 2000);
    }

    function endGame(text) {
        gameActive = false;
        document.getElementById('center-msg').innerText = text;
        document.getElementById('center-msg').style.display = 'block';
        document.getElementById('center-msg').style.color = '#00ff00';
    }

    init();

</script>
</body>
</html>